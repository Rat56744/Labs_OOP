# Теория по C++

## Оглавление
1. [Структура заголовочных файлов и файлов реализации. Как правильно подключать заголовочные файлы?. Объявления(declarations) и определения(definitions). ](#заголовочные-файлы)  
2. [Модульные заголовки. Пример применения](#модульные-заголовочные-файлы)  
3. [](#)  

---

## Заголовочные файлы
В C++ принято разделять **объявления** (declarations) и **определения** (definitions) для улучшения организации кода и ускорения компиляции.  

### **1. Где что должно находиться?**
| Тип файла | Содержание | Расширение |
|-----------|------------|------------|
| **Заголовочный файл** (`*.h`, `*.hpp`) | **Объявления** классов, функций, структур, `extern`-переменных, шаблонов. | `.h` или `.hpp` |
| **Файл реализации** (`*.cpp`, `*.cc`, `*.cxx`) | **Определения** функций, методов классов, статических переменных. | `.cpp`, `.cc`, `.cxx` |

### **2. Как это работает в вашем случае?**
#### **Если класс/функция используется в нескольких `.cpp`-файлах:**
- **Заголовочный файл (`*.h`/`*.hpp`)** → объявление класса/функции.
- **Файл реализации (`*.cpp`)** → реализация методов/функций.

**Пример:**  
```cpp
// === my_class.h ===
#pragma once  // Защита от повторного включения

class MyClass {
public:
    void doSomething();  // Объявление метода
};
```

```cpp
// === my_class.cpp ===
#include "my_class.h"

void MyClass::doSomething() {  // Определение метода
    // Реализация...
}
```

```cpp
// === main.cpp ===
#include "my_class.h"  // Подключаем только заголовок

int main() {
    MyClass obj;
    obj.doSomething();
    return 0;
}
```

#### **Если класс/функция используется только в одном `.cpp`-файле:**
Можно определить прямо в `.cpp` без заголовочного файла:
```cpp
// === utils.cpp ===
namespace {
    void helperFunction() { ... }  // Локальная функция, видима только в этом файле
}
```

### **3. Почему важно разделять `.h` и `.cpp`?**
✅ **Ускорение компиляции**  
- Если изменить реализацию в `.cpp`, перекомпилируется только он.  
- Если изменить заголовочный файл, перекомпилируются все `.cpp`, которые его включают.  

✅ **Избежание множественных определений**  
- Определения функций/методов в `.h` могут привести к **нарушению ODR (One Definition Rule)**, если файл включён в несколько `.cpp`.  

✅ **Чистота кода**  
- Заголовочные файлы — это "интерфейс", который видят другие разработчики.  
- Реализация скрыта в `.cpp`.  

### **4. Исключения (когда можно писать всё в `.h`)**  
1. **Шаблоны (`template`)**  
   Их реализация **должна** быть в заголовочном файле, потому что компилятор инстанцирует их на месте.  
   ```cpp
   // === math_utils.h ===
   template <typename T>
   T add(T a, T b) { return a + b; }  // Определение шаблона в .h
   ```

2. **Inline-функции**  
   Если функция объявлена как `inline`, её определение можно (и часто нужно) поместить в `.h`.  

3. **Маленькие приватные классы**  
   Если класс используется только в одном `.cpp`, его можно определить прямо там (без `.h`).  

### **Вывод**
- **Класс/функция используется в нескольких `.cpp`?**  
  → Разделяйте на `.h` (объявление) и `.cpp` (реализация).  
- **Класс/функция используется только в одном `.cpp`?**  
  → Можно оставить в `.cpp` без `.h`.  
- **Шаблоны или `inline`-функции?**  
  → Определения должны быть в `.h`.  

Если ваш класс подключается через заголовочный файл (`stdfax.h`), то:  
- **Объявление класса** → в `.h` (например, `my_class.h`).  
- **Реализация методов** → в `.cpp` (например, `my_class.cpp`).  
- **Подключение в `main.cpp`** → только `#include "my_class.h"`.

---


## Модульные заголовочные файлы

### **Что такое модульный заголовок для связанных классов?**  
**Модульный заголовок** — это заголовочный файл (`*.h`), который включает несколько связанных классов, чтобы упростить их использование в других частях программы.  

#### **Когда его использовать?**  
- Если **несколько классов логически связаны** (например, `Car` и `Engine`).  
- Если эти классы **часто используются вместе** (чтобы не подключать каждый по отдельности).  
- Если нужно **упростить включение зависимостей** в `main.cpp` или других файлах.  

---

### **Пример: модульный заголовок для связанных классов**  
#### **1. Классы по отдельности (базовый вариант)**  
Допустим, у нас есть два класса: `Engine` и `Car`, где `Car` использует `Engine`.  

##### **`Engine.h`**  
```cpp
#pragma once

class Engine {
public:
    void start();
};
```

##### **`Engine.cpp`**  
```cpp
#include "Engine.h"
#include <iostream>

void Engine::start() {
    std::cout << "Engine started!\n";
}
```

##### **`Car.h`**  
```cpp
#pragma once
#include "Engine.h"  // Car зависит от Engine

class Car {
    Engine engine;
public:
    void drive();
};
```

##### **`Car.cpp`**  
```cpp
#include "Car.h"

void Car::drive() {
    engine.start();
    std::cout << "Car is moving!\n";
}
```

##### **`main.cpp`**  
```cpp
#include "Car.h"  // Подключаем Car, который уже включает Engine

int main() {
    Car car;
    car.drive();
    return 0;
}
```

#### **2. Добавляем модульный заголовок (`VehicleModule.h`)**  
Если `Car` и `Engine` всегда используются вместе, можно создать общий заголовочный файл:  

##### **`VehicleModule.h`**  
```cpp
#pragma once
#include "Engine.h"
#include "Car.h"
```

##### **Теперь `main.cpp` можно упростить:**  
```cpp
#include "VehicleModule.h"  // Вместо отдельных Car.h и Engine.h

int main() {
    Car car;
    car.drive();
    return 0;
}
```

---

### **Что подключать в самих классах?**  
- **В `Car.h` остаётся `#include "Engine.h"`**, потому что `Car` напрямую зависит от `Engine`.  
- **`VehicleModule.h` подключается только в `main.cpp`** (или других файлах, где нужны оба класса).  

#### **Схема зависимостей:**
```
main.cpp → VehicleModule.h → Car.h → Engine.h
                              ↑
                              └────── Engine.cpp
```

---

### **Плюсы модульного заголовка**  
✅ **Упрощает включение зависимостей** (вместо 2+ `#include` — один).  
✅ **Логически группирует связанные классы**.  
✅ **Не нарушает инкапсуляцию** (классы по-прежнему видят только то, что им нужно).  

---

### **Когда это избыточно?**  
- Если классы **редко используются вместе**.  
- Если включение лишних заголовков **замедляет компиляцию**.  

---

### **Вывод**  
Модульный заголовок — это **удобная обёртка для группы связанных классов**, но сами классы должны подключать только то, что им нужно.  

#### **Итоговая структура проекта:**
```
/src
├── /vehicles
│   ├── Engine.h
│   ├── Engine.cpp
│   ├── Car.h
│   ├── Car.cpp
│   └── VehicleModule.h  // Модульный заголовок
└── main.cpp
```  

В `main.cpp` подключаем `VehicleModule.h`, а в `Car.h` — `Engine.h`. Так сохраняется чистота зависимостей.

## 